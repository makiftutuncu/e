
[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-java

This module contains implementation of `e-core` written in Java.

## E

[`E`](src/main/java/e/java/E.java) provides a concrete implementation of `AbstractE` as an immutable class. Any modifications on an `E` instance return a new instance.

Here are some examples:

```java
import java.util.*;
import e.java.*;

/***********************/
/* Empty E definitions */
/***********************/

E e1 = E.empty();
// {}

E e2 = new E();
// {}

/**********************************************************************************/
/* Constructing an E, mix and match constuctor and builder methods as you see fit */
/**********************************************************************************/

Exception ae = new java.lang.ArithmeticException();

Map<String, String> data1 = new HashMap<>();
data1.put("input", "5");
E e3 = new E("arithmetic-error", "Cannot divide number by 0!", 1, ae, data1);
// {"name":"arithmetic-error","message":"Cannot divide number by 0!","code":1,"cause":"...","data":{"input":"5"}}

E e4 = E.empty().name("arithmetic-error").message("Cannot divide number by 0!").code(1).cause(ae).data("input", "5");
// {"name":"arithmetic-error","message":"Cannot divide number by 0!","code":1,"cause":"...","data":{"input":"5"}}

E e5 = new E("arithmetic-error", "Cannot divide number by 0!").cause(ae).data("input", "5");
// {"name":"arithmetic-error","message":"Cannot divide number by 0!","code":1,"cause":"...","data":{"input":"5"}}

/****************************************/
/* Checking existence of fields of an E */
/****************************************/

boolean errorContainsCode = new E("error").hasCode();
// false

/****************************/
/* Accessing fields of an E */
/****************************/

boolean errorContainsInput = new E().data("input", "test").data().get("input") != null
// true

/*************************************************************/
/* Converting E to an Exception, for throwing stuff (unsafe) */
/*************************************************************/

Excpetion ex = new E("test", "Test").toException();

/*******************************************************/
/* Converting E to a Maybe, for returning stuff (safe) */
/*******************************************************/

Maybe<Integer> maybe = new E("error").toMaybe();
// {"name":"error"}

```

## Maybe

[`Maybe`](src/main/java/e/java/Maybe.java) provides a type safe way to denote a value. It can either contain an `E` or a value of type `A`.

Here are some examples:

```java
import java.util.*;
import e.java.*;

/********************************/
/* Constructing a success Maybe */
/********************************/

Maybe<Integer> maybe1 = Maybe.success(5);
// 5

/********************************/
/* Constructing a failure Maybe */
/********************************/

Maybe<String> maybe2 = Maybe.failure(new E("e-2"));
// {"name":"e-2"}

/*****************************/
/* Constructing a unit Maybe */
/*****************************/

Maybe<Void> unit = Maybe.unit();
// unit

boolean unitEOptional = unit.eOptional().isPresent();
// false

boolean unitValueOptional = unit.valueOptional().isPresent();
// false

/*****************************************************/
/* Constructing a Maybe from a lambda that can throw */
/*****************************************************/

Maybe<Integer> maybe3 = Maybe.catching(() -> 3 / 0, t -> new E("divide-error").cause(t));
// {"name":"divide-error","cause":"..."}

Maybe<Integer> maybe4 = Maybe.catching(() -> 3 / 2, t -> new E("divide-error").cause(t));
// 1

/***********************************************************/
/* Constructing a Maybe from a Maybe lambda that can throw */
/***********************************************************/

Maybe<Integer> maybe5 = Maybe.catchingMaybe(() -> Maybe.failure(new E()), t -> new E("divide-error").cause(t));
// {}

Maybe<Integer> maybe6 = Maybe.catchingMaybe(() -> Maybe.success(3 / 0), t -> new E("divide-error").cause(t));
// {"name":"divide-error","cause":"..."}

Maybe<Integer> maybe7 = Maybe.catchingMaybe(() -> Maybe.success(3 / 2), t -> new E("divide-error").cause(t));
// 1

/**************************************/
/* Constructing a Maybe from nullable */
/**************************************/

Maybe<String> maybe8 = Maybe.nullable(null, () -> new E("null-value"));
// {"name":"null-value"}

Maybe<String> maybe9 = Maybe.nullable("test", () -> new E("null-value"));
// test

/**************************************/
/* Constructing a Maybe from Optional */
/**************************************/

Maybe<String> maybe10 = Maybe.fromOptional(null, () -> new E("empty"));
// {"name":"empty"}

Maybe<String> maybe11 = Maybe.fromOptional(Optional.empty(), () -> new E("empty"));
// {"name":"empty"}

Maybe<String> maybe12 = Maybe.fromOptional(Optional.of("test"), () -> new E("empty"));
// test

/*******************************/
/* Checking content of a Maybe */
/*******************************/

maybe1.isSuccess();
// true

maybe2.isSuccess();
// false

Optional<E> eOpt1 = maybe1.eOptional();
// Optional.empty

Optional<Integer> valueOpt1 = maybe1.valueOptional();
// Optional[5]

Optional<E> eOpt2 = maybe2.eOptional();
// Optional[{"name":"e-2"}]

Optional<Integer> valueOpt2 = maybe2.valueOptional();
// Optional.empty

/*******************/
/* Mapping a Maybe */
/*******************/

Maybe<Integer> mapped1 = new E("error").toMaybe<Integer>().map(i -> i * 2);
// {"name":"error"}

Maybe<Integer> mapped2 = Maybe.success(5).map(i -> i * 2);
// 10

/************************/
/* Flat mapping a Maybe */
/************************/

Maybe<Integer> flatMapped1 = new E("error").toMaybe<Integer>().flatMap(i -> Maybe.success(i * 2));
// {"name":"error"}

Maybe<Boolean> flatMapped2 = Maybe.success(5).flatMap(i -> new E("error").toMaybe<Boolean>())
// {"name":"error"}

Maybe<String> flatMapped3 = Maybe.success(5).flatMap(i -> Maybe.success<String>((i * 2).toString()))
// 10

/*******************/
/* Folding a Maybe */
/*******************/

String folded1 = new E("error").toMaybe<Integer>().fold<String>(e -> "failure", value -> "success");
// failure

String folded2 = Maybe.success(5).fold<String>(e -> "failure", value -> "success");
// success

/**********************************************************/
/* Getting value of a Maybe and providing a default value */
/**********************************************************/

int value1 = new E("error").toMaybe<Integer>().getOrElse(0);
// 0

String value2 = Maybe.success("test").getOrElse("");
// test

/************************************/
/* Providing an alternative a Maybe */
/************************************/

Maybe<Integer> alternative1 = new E("error1").toMaybe<Integer>().orElse(new E("error2").toMaybe<Integer>());
// {"name":"error2"}

Maybe<String> alternative2 = Maybe.success("test").orElse(new E("error1").toMaybe<String>());
// test

Maybe<Integer> alternative3 = new E("error1").toMaybe<Integer>().orElse(Maybe.success(0));
// 0

/*******************************************************/
/* Ignoring previous value and moving to another Maybe */
/*******************************************************/

Maybe<Integer> andThen1 = new E("error").toMaybe<Integer>().andThen(() -> Maybe.success(5));
// {"name":"error"}

Maybe<Integer> andThen2 = new E("error-1").toMaybe<Integer>().andThen(() -> new E("error-2").toMaybe<Integer>())
// {"name":"error-1"}

Maybe<Integer> andThen3 = Maybe.success(5).andThen(() -> new E("error").toMaybe<Integer>())
// {"name":"error"}

Maybe<String> andThen4 = Maybe.success("test-1").andThen(() -> Maybe.success<String>("test-2"))
// test-2

/*********************/
/* Filtering a Maybe */
/*********************/

Maybe<Integer> filtered1 = Maybe.failure(new E("error")).filter(i -> i < 4));
// {"name":"error"}

Maybe<Integer> filtered2 = Maybe.failure(new E("error")).filter(i -> i < 4, i -> new E("error-2").data("value", i)));
// {"name":"error"}

Maybe<Integer> filtered3 = Maybe.success(5).filter(i -> i < 4));
// {"name":"predicate-failed","message":"Value did not satisfy predicate!","data":{"value":"5"}}

Maybe<Integer> filtered4 = Maybe.success(5).filter(i -> i < 4, i -> new E("error-2").data("value", i)));
// {"name":"error-2","data":{"value":"5"}}

Maybe<Integer> filtered5 = Maybe.success(5).filter(i -> i > 4));
// 5

Maybe<Integer> filtered6 = Maybe.success(5).filter(i -> i > 4, i -> new E("error-2").data("value", i)));
// 5

/******************************************/
/* Using a Maybe to perform a side effect */
/******************************************/

StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder();

E("error").toMaybe<String>().forEach(s -> sb1.append(s));
"test".toMaybe().forEach(s -> sb2.append(s));

String forEach1 = sb1.toString();
// ""

String forEach2 = sb2.toString();
// "test"

/*****************************/
/* Handling error of a Maybe */
/*****************************/

Maybe<Integer> handled1 = new E("error").toMaybe().handleError(e -> 0);
// 0

Maybe<Integer> handled2 = new E("error").code(1).toMaybe().handleError(AbstracE::code);
// 1

Maybe<Integer> handled3 = Maybe.success(5).handleError(e -> 0);
// 5

Maybe<Integer> handled4 = Maybe.success(5).handleError(AbstractE::code);
// 5

/************************************************/
/* Handling error of a Maybe with another Maybe */
/************************************************/

Maybe<Integer> handledWith1 = new E("error-1").toMaybe().handleErrorWith(e -> new E().toMaybe());
// {}

Maybe<Integer> handledWith2 = new E("error-1").toMaybe().handleErrorWith(e -> Maybe.success(5));
// 5

Maybe<Integer> handledWith3 = new E("error-1").toMaybe().handleErrorWith(e -> e.code(1).toMaybe());
// {"name":"error-1","code":1}

Maybe<Integer> handledWith4 = new E("error-1").code(1).toMaybe().handleErrorWith(e -> Maybe.success(e.code()));
// 1

Maybe<Integer> handledWith5 = Maybe.success(5).handleErrorWith(e -> new E().toMaybe());
// 5

Maybe<Integer> handledWith5 = Maybe.success(5).handleErrorWith(e -> new E("error-1").toMaybe());
// 5

Maybe<Integer> handledWith5 = Maybe.success(5).handleErrorWith(e -> e.code(1).toMaybe());
// 5

Maybe<Integer> handledWith5 = Maybe.success(5).handleErrorWith(e -> Maybe.success(e.code()));
// 5

```

## Encoder

[`Encoder<OUT>`](src/main/java/e/java/Encoder.java) provides encode functionality such that given `E` can be converted to another value of type `OUT`. There is [`JsonStringEncoder`](src/main/java/e/java/JsonStringEncoder.java) as a default `Encoder<String>` implementation.

```java
import java.util.*;
import e.java.*;

/*******************************/
/* Default Json string encoder */
/*******************************/

Encoder<String> encoder = JsonStringEncoder.get();

String encoded1 = encoder.encode(new E());
// {}

String encoded2 = encoder.encode(new E("test-name", "Test Message", 3, new Exception("Test Cause")).data("test", "data"));
// {"name":"test-name","message":"Test Message","code":3,"cause":"Test Cause","data":{"test":"data"}}

/******************************************************/
/* Custom CSV-like encoder for demonstration purposes */
/******************************************************/

Encoder<String> csv = e -> String.format(
    "\"name\",\"message\",\"code\"\n\"%s\",\"%s\",\"%d\"",
    e.name(),
    e.message(),
    e.code()
);

String csv1 = csv.encode(new E());
// "name","message","code"
// "","","0"

String csv2 = csv.encode(new E("test-name", "Test Message", 3, new Exception("Test Cause")).data("test", "data")));
// "name","message","code"
// "test-name","Test Message","3"

```

## Decoder

[`Decoder<IN>`](src/main/java/e/java/Decoder.java) provides decode functionality such that given an input of type `IN`, an `E` can be constructed. Since decoding often includes parsing, it can possibly fail. `DecoderResult` exists for this purpose. It can either contain successfully decoded `E` or an `E` describing the error occurred during decoding.

```java
import java.util.*;
import e.java.*;

import e.AbstractDecoder.DecodingResult;

/******************************************************/
/* Custom CSV-like decoder for demonstration purposes */
/******************************************************/

Decoder<String> csv = new Decoder<String>() {
    @Override public DecodingResult<E> decode(String input) {
        String[] rows = input.split("\n");
        if (rows.length < 2) {
            return DecodingResult.fail(new E("decoding-failure", "Input did not have 2 rows!"));
        }

        String[] columns = rows[1].split(",");
        if (columns.length < 3) {
            return DecodingResult.fail(new E("decoding-failure", "Input did not have 3 columns!"));
        }

        String name    = unescape(columns[0]);
        String message = unescape(columns[1]);

        try {
            int code = Integer.parseInt(unescape(columns[2]));

            return DecodingResult.succeed(new E(name, message, code));
        } catch (Exception e) {
            return DecodingResult.fail(new E("decoding-failure", "Invalid code!").cause(e).data("code", columns[3]));
        }
    }

    private String unescape(String s) {
        return (s.startsWith("\"") && s.endsWith("\"")) ? s.substring(1, s.length() - 2) : s;
    }
};

DecodingResult<E> result1 = csv.decode("foo");

boolean isSuccess1 = result1.isSuccess();
// false

E e1 = result1.get();
// {"name":"decoding-failure","message":Input did not have 2 columns!"}

DecodingResult<E> result2 = csv.decode("\"name\",\"message\",\"code\"\n\"test-name\",\"Test Message\",\"3\"");

boolean isSuccess2 = result2.isSuccess();
// true

E e2 = result2.get();
// {"name":"test-name","message":Test Message","code":3}

```

## Codec

[`Codec<A>`](src/main/java/e/java/Codec.java) is simply a combination of both `Encoder<A>` and `Decoder<A>` for the same type `A`.
