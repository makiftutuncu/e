[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-scala

This is the main implementation of e in Scala. It contains two main types [E](src/main/scala/e/scala/E.scala) and [EOr](src/main/scala/e/scala/EOr.scala). It also contains decoding and encoding definitions for these. Decoding and encoding implementations are provided by separate modules.

## Installation

If you use SBT, add following to your `build.sbt`:

```scala
libraryDependencies += "dev.akif" %% "e-scala" % "@VERSION@"
```
If you use Maven, add following to your `pom.xml` where `[SCALA_VERSION]` is your Scala version (i.e. 2.12 or 2.13):

```xml
<dependencies>
  <dependency>
    <groupId>dev.akif</groupId>
    <artifactId>e-scala_[SCALA_VERSION]</artifactId>
    <version>@VERSION@</version>
  </dependency>
</dependencies>
```
If you use Gradle, add following to your project's `build.gradle` where `[SCALA_VERSION]` is your Scala version (i.e. 2.12 or 2.13):

```javascript
dependencies {
  implementation('dev.akif:e-scala_[SCALA_VERSION]:@VERSION@')
}
```

## Contents

Below are some details and examples of e-scala's content. For more, please check corresponding automated tests and Scaladoc.

### 1. E

E (short for error) is the main error type used to represent an error. It is immutable object with a fluent API. It contains following data about the error.

| Field   | Type                  | Description                                               | Default Value |
| ------- | --------------------- | --------------------------------------------------------- | ------------- |
| code    | `Option[Int]`         | A numeric code identifying the error                      | `None`        |
| name    | `Option[String]`      | A name identifying the error, usually enum-like           | `None`        |
| message | `Option[String]`      | A message about the error, usually human-readable         | `None`        |
| causes  | `List[E]`             | Underlying cause(s) of the error, if any                  | `List.empty`  |
| data    | `Map[String, String]` | Arbitrary data related to the error as a key-value map    | `Map.empty`   |
| time    | `Option[Long]`        | Time when this error occurred as milliseconds since Epoch | `None`        |

#### 1.1. Creating an E

An instance of E can be created by

* directly creating an instance
* modifying an existing instance
* using static constructor methods

```scala mdoc
import e.scala._

E.empty

val notSoEmpty = E(Some(1), Some("error-name"), Some("Error Message"))

E.name("test-error").message("Test")

val unexpectedError = E(message = Some("Unexpected Error"), code = Some(-1)).now

val errorWithDataAndCause = unexpectedError.data("action" -> "test").cause(notSoEmpty)
```

#### 1.2. Accessing Data in E

Since E is a case class, you can directly access its fields. There are additional methods as well.

```scala mdoc
import e.scala._

val databaseError = E.name("database").code(1)

val e1 = E(message = Some("Cannot get user!"), name = Some("Unknown")).cause(databaseError)

e1.message

e1.code orElse (e1.causes.headOption.flatMap(_.code))

e1.hasData

e1.trace
```

#### 1.3. Converting E

You can convert your E into an Exception or an EOr.

```scala mdoc
import e.scala._

val e2 = E.name("test").message("Test")

e2.toException

e2.toEOr[Int]
```

### 2. EOr

EOr[A] (which can be aliased with a syntactic sugar as: `E or A`) is a container that can either be a `Failure` containing an E or `Success` containing a value of type `A`. It is semantically a combination of Scala's `Either` and `Try` but it is specialized for E in error case.

#### 2.1. Creating an EOr

An instance of EOr can be created by

* directly creating an instance of Failure or Success
* modifying an existing instance
* using static constructor methods
* constructing from an E or a value
* converting from other types by extension methods

```scala mdoc
import e.scala._
import e.scala.EOr.{Failure, Success}

EOr[Boolean](E.code(0))

EOr("hello")

Failure(E.code(1))

Success("test")

E.message("test").toEOr[Int]

"hello".orE

Some(true).orE(E.code(2))

Option.empty[String].orE(E.code(3))

EOr.fromEither[Int, String](Right("hello")) { left => E.code(left) }

EOr.fromEither[Int, String](Left(4)) { left => E.code(left) }
```

#### 2.2. Accessing Content of an EOr

TODO

#### 2.3. Modifying an EOr and Composing

TODO

### 3. Codec, Decoder and Encoder

TODO