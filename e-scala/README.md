[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-scala [![](https://img.shields.io/badge/docs-2.0.0-SNAPSHOT-brightgreen.svg?style=for-the-badge&logo=scala&color=dc322f&labelColor=333333)](https://javadoc.io/doc/dev.akif/e-scala)

This is the main implementation of e in Scala. It contains two main types [E](src/main/scala/e/scala/E.scala) and [EOr](src/main/scala/e/scala/EOr.scala). It also contains definitions of decoding and encoding for these. Implementations of decoding and encoding are provided in separate modules.

## Installation

If you use SBT, add following to your `build.sbt`:

```scala
libraryDependencies += "dev.akif" %% "e-scala" % "2.0.0-SNAPSHOT"
```
If you use Maven, add following to your `pom.xml` (replace 2.13 if you need a different Scala version):

```xml
<dependencies>
  <dependency>
    <groupId>dev.akif</groupId>
    <artifactId>e-scala_2.13</artifactId>
    <version>2.0.0-SNAPSHOT</version>
  </dependency>
</dependencies>
```
If you use Gradle, add following to your project's `build.gradle` (replace 2.13 if you need a different Scala version):

```javascript
dependencies {
  implementation('dev.akif:e-scala_2.13:2.0.0-SNAPSHOT')
}
```

## Contents

Below are some details and examples of e-scala's content. For more, please check corresponding automated tests and e-scala's documentation.

To get started, add following import which will cover all your needs:

```scala
import e.scala._
```

### 1. E

E (short for error) is the main error type used to represent an error. It is an immutable object with a fluent API. It contains following data about the error.

| Field   | Type                  | Description                                               | Default Value |
| ------- | --------------------- | --------------------------------------------------------- | ------------- |
| code    | `Option[Int]`         | A numeric code identifying the error                      | `None`        |
| name    | `Option[String]`      | A name identifying the error, usually enum-like           | `None`        |
| message | `Option[String]`      | A message about the error, usually human-readable         | `None`        |
| causes  | `List[E]`             | Underlying cause(s) of the error, if any                  | `List.empty`  |
| data    | `Map[String, String]` | Arbitrary data related to the error as a key-value map    | `Map.empty`   |
| time    | `Option[Long]`        | Time when this error occurred as milliseconds since Epoch | `None`        |

#### 1.1. Creating an E

An instance of E can be created by

* directly creating an instance
* modifying an existing instance
* using static constructor methods

```scala
import e.scala._

E.empty
// res1: E = {}

val notSoEmpty = E(Some(1), Some("error-name"), Some("Error Message"))
// notSoEmpty: E = {"code":1,"name":"error-name","message":"Error Message"}

E.name("test-error").message("Test")
// res2: E = {"name":"test-error","message":"Test"}

val unexpectedError = E(message = Some("Unexpected Error"), code = Some(-1)).now
// unexpectedError: E = {"code":-1,"message":"Unexpected Error","time":1597699594081}

val errorWithDataAndCause = unexpectedError.data("action" -> "test").cause(notSoEmpty)
// errorWithDataAndCause: E = {"code":-1,"message":"Unexpected Error","causes":[{"code":1,"name":"error-name","message":"Error Message"}],"data":{"action":"test"},"time":1597699594081}
```

#### 1.2. Accessing Data in E

Since E is a case class, you can directly access its fields. There are additional methods as well.

```scala
import e.scala._

val databaseError = E.name("database").code(1)
// databaseError: E = {"code":1,"name":"database"}

val error = E(message = Some("Cannot get user!"), name = Some("Unknown")).cause(databaseError)
// error: E = {"name":"Unknown","message":"Cannot get user!","causes":[{"code":1,"name":"database"}]}

error.message
// res4: Option[String] = Some(Cannot get user!)

error.code orElse (error.causes.headOption.flatMap(_.code))
// res5: Option[Int] = Some(1)

error.hasData
// res6: Boolean = false
```

#### 1.3. Converting E

You can convert your E into an Exception or an EOr.

```scala
import e.scala._

val error = E.name("test").message("Test")
// error: E = {"name":"test","message":"Test"}

error.toException
// res8: EException = {"name":"test","message":"Test"}

error.toEOr[Int]
// res9: EOr[Int] = {"name":"test","message":"Test"}
```

### 2. EOr

EOr[A] (which can be aliased with a syntactic sugar as: `E or A`) is a container that can either be a `Failure` containing an E or `Success` containing a value of type `A`. It is semantically a combination of Scala's `Either` and `Try` but it is specialized for E in error case.

#### 2.1. Creating an EOr

An instance of EOr can be created by

* directly creating an instance of Failure or Success
* modifying an existing instance
* using static constructor methods
* constructing from an E or a value
* converting from other types by extension methods

```scala
import e.scala._

EOr[Boolean](E.code(0))
// res11: EOr[Boolean] = {"code":0}

EOr("hello")
// res12: EOr[String] = hello

EOr.Failure(E.code(1))
// res13: EOr.Failure = {"code":1}

EOr.Success("test")
// res14: EOr.Success[String] = test

E.message("test").toEOr[Int]
// res15: EOr[Int] = {"message":"test"}

"hello".toEOr
// res16: EOr[String] = hello

Some(true).toEOr(E.code(2))
// res17: EOr[Boolean] = true

Option.empty[String].toEOr(E.code(3))
// res18: EOr[String] = {"code":3}

EOr.fromEither[Int, String](Right("hello")) { left => E.code(left) }
// res19: EOr[String] = hello

EOr.fromEither[Int, String](Left(4)) { left => E.code(left) }
// res20: EOr[String] = {"code":4}
```

#### 2.2. Accessing Content of an EOr

The error or the value inside an EOr can be accessed safely.

```scala
import e.scala._

val eor1 = E.message("test").toEOr[Int]
// eor1: EOr[Int] = {"message":"test"}

val eor2 = "hello".toEOr
// eor2: EOr[String] = hello

eor1.hasValue
// res22: Boolean = false

eor1.error
// res23: Option[E] = Some({"message":"test"})

eor2.hasError
// res24: Boolean = false

eor2.value
// res25: Option[String] = Some(hello)
```

#### 2.3. Working With EOr

There are many methods in EOr for modifying, composing, handling the error etc.

```scala
import e.scala._

val eor1 = E.message("test").toEOr[Int]
// eor1: EOr[Int] = {"message":"test"}

val eor2 = "hello".toEOr
// eor2: EOr[String] = hello

eor2.map(_.toUpperCase)
// res27: EOr[String] = HELLO

eor1.mapError(_.code(1))
// res28: EOr[Int] = {"code":1,"message":"test"}

eor2.flatMap(s => eor1)
// res29: EOr[Int] = {"message":"test"}

eor2.filter(_.length < 3)
// res30: EOr[String] = {"name":"filtered","message":"Condition does not hold!","data":{"value":"hello"}}

eor1.getOrElse(0)
// res31: Int = 0

eor1.fold(e => e.code, i => Some(i)).getOrElse(0)
// res32: Int = 0

case class Person(name: String, age: Int)

def makePerson(name: String, age: Int): EOr[Person] =
  // You can do for-comprehensions too!
  for {
    n <- EOr(name) if name.nonEmpty
    a <- EOr(age).filter(_ > 0, invalidAge => E.name("invalid-age").data("value" -> invalidAge)) // custom error for filtering
  } yield {
    Person(n, a)
  }

makePerson("", 5)
// res33: EOr[Person] = {"name":"filtered","message":"Condition does not hold!","data":{"value":""}}

makePerson("Akif", -1)
// res34: EOr[Person] = {"name":"invalid-age","data":{"value":"-1"}}

makePerson("Akif", 29)
// res35: EOr[Person] = Person(Akif,29)
```

### 3. Codec, Decoder and Encoder

e-scala provides definitions for implementing decoding/encoding mechanism for E and EOr.

* [Decoder[I, O]](src/main/scala/e/scala/codec/Decoder.scala) is for building an `O` (output) from an `I` (input) while handling the decoding failures with E
* [Encoder[I, O]](src/main/scala/e/scala/codec/Encoder.scala) is for building an `O` (output) from an `I` (input)
* [Codec[S, T]](src/main/scala/e/scala/codec/Codec.scala) is a combination of Decoder and Encoder for an `S` (source) type where output of Encoder and input of Decoder is the same `T` (target) type
