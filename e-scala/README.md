[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-scala

This is the main implementation of e in Scala. It contains two main types [E](src/main/scala/e/scala/E.scala) and [EOr](src/main/scala/e/scala/EOr.scala). It also contains decoding and encoding definitions for these. Decoding and encoding implementations are provided by separate modules.

## Installation

If you use SBT, add following to your `build.sbt`:

```scala
libraryDependencies += "dev.akif" %% "e-scala" % "2.0.0-SNAPSHOT"
```
If you use Maven, add following to your `pom.xml` where `[SCALA_VERSION]` is your Scala version (i.e. 2.12 or 2.13):

```xml
<dependencies>
  <dependency>
    <groupId>dev.akif</groupId>
    <artifactId>e-scala_[SCALA_VERSION]</artifactId>
    <version>2.0.0-SNAPSHOT</version>
  </dependency>
</dependencies>
```
If you use Gradle, add following to your project's `build.gradle` where `[SCALA_VERSION]` is your Scala version (i.e. 2.12 or 2.13):

```javascript
dependencies {
  implementation('dev.akif:e-scala_[SCALA_VERSION]:2.0.0-SNAPSHOT')
}
```

## Contents

Below are some details and examples of e-scala's content. For more, please check corresponding automated tests and Scaladoc.

### 1. E

E (short for error) is the main error type used to represent an error. It is immutable object with a fluent API. It contains following data about the error.

| Field   | Type                  | Description                                               | Default Value |
| ------- | --------------------- | --------------------------------------------------------- | ------------- |
| code    | `Option[Int]`         | A numeric code identifying the error                      | `None`        |
| name    | `Option[String]`      | A name identifying the error, usually enum-like           | `None`        |
| message | `Option[String]`      | A message about the error, usually human-readable         | `None`        |
| causes  | `List[E]`             | Underlying cause(s) of the error, if any                  | `List.empty`  |
| data    | `Map[String, String]` | Arbitrary data related to the error as a key-value map    | `Map.empty`   |
| time    | `Option[Long]`        | Time when this error occurred as milliseconds since Epoch | `None`        |

#### 1.1. Creating an E

An instance of E can be created by

* directly creating an instance
* modifying an existing instance
* using static constructor methods

```scala
import e.scala._

E.empty
// res0: E = E(None, None, None, List(), Map(), None)

val notSoEmpty = E(Some(1), Some("error-name"), Some("Error Message"))
// notSoEmpty: E = E(
//   Some(1),
//   Some("error-name"),
//   Some("Error Message"),
//   List(),
//   Map(),
//   None
// )

E.name("test-error").message("Test")
// res1: E = E(None, Some("test-error"), Some("Test"), List(), Map(), None)

val unexpectedError = E(message = Some("Unexpected Error"), code = Some(-1)).now
// unexpectedError: E = E(
//   Some(-1),
//   None,
//   Some("Unexpected Error"),
//   List(),
//   Map(),
//   Some(1595164361089L)
// )

val errorWithDataAndCause = unexpectedError.data("action" -> "test").cause(notSoEmpty)
// errorWithDataAndCause: E = E(
//   Some(-1),
//   None,
//   Some("Unexpected Error"),
//   List(
//     E(Some(1), Some("error-name"), Some("Error Message"), List(), Map(), None)
//   ),
//   Map("action" -> "test"),
//   Some(1595164361089L)
// )
```

#### 1.2. Accessing Data in E

Since E is a case class, you can directly access its fields. There are additional methods as well.

```scala
import e.scala._

val databaseError = E.name("database").code(1)
// databaseError: E = E(Some(1), Some("database"), None, List(), Map(), None)

val e1 = E(message = Some("Cannot get user!"), name = Some("Unknown")).cause(databaseError)
// e1: E = E(
//   None,
//   Some("Unknown"),
//   Some("Cannot get user!"),
//   List(E(Some(1), Some("database"), None, List(), Map(), None)),
//   Map(),
//   None
// )

e1.message
// res2: Option[String] = Some("Cannot get user!")

e1.code orElse (e1.causes.headOption.flatMap(_.code))
// res3: Option[Int] = Some(1)

e1.hasData
// res4: Boolean = false

e1.trace
// res5: String = """Unknown | Cannot get user!
//   E1 | database"""
```

#### 1.3. Converting E

You can convert your E into an Exception or an EOr.

```scala
import e.scala._

val e2 = E.name("test").message("Test")
// e2: E = E(None, Some("test"), Some("Test"), List(), Map(), None)

e2.toException
// res6: EException = EException(
//   E(None, Some("test"), Some("Test"), List(), Map(), None)
// )

e2.toEOr[Int]
// res7: EOr[Int] = Failure(
//   E(None, Some("test"), Some("Test"), List(), Map(), None)
// )
```

### 2. EOr

EOr[A] (which can be aliased with a syntactic sugar as: `E or A`) is a container that can either be a `Failure` containing an E or `Success` containing a value of type `A`. It is semantically a combination of Scala's `Either` and `Try` but it is specialized for E in error case.

#### 2.1. Creating an EOr

An instance of EOr can be created by

* directly creating an instance of Failure or Success
* modifying an existing instance
* using static constructor methods
* constructing from an E or a value
* converting from other types by extension methods

```scala
import e.scala._
import e.scala.EOr.{Failure, Success}

EOr[Boolean](E.code(0))
// res8: EOr[Boolean] = Failure(E(Some(0), None, None, List(), Map(), None))

EOr("hello")
// res9: EOr[String] = Success("hello")

Failure(E.code(1))
// res10: Failure = Failure(E(Some(1), None, None, List(), Map(), None))

Success("test")
// res11: Success[String] = Success("test")

E.message("test").toEOr[Int]
// res12: EOr[Int] = Failure(E(None, None, Some("test"), List(), Map(), None))

"hello".orE
// res13: EOr[String] = Success("hello")

Some(true).orE(E.code(2))
// res14: EOr[Boolean] = Success(true)

Option.empty[String].orE(E.code(3))
// res15: EOr[String] = Failure(E(Some(3), None, None, List(), Map(), None))

EOr.fromEither[Int, String](Right("hello")) { left => E.code(left) }
// res16: EOr[String] = Success("hello")

EOr.fromEither[Int, String](Left(4)) { left => E.code(left) }
// res17: EOr[String] = Failure(E(Some(4), None, None, List(), Map(), None))
```

#### 2.2. Accessing Content of an EOr

TODO

#### 2.3. Modifying an EOr and Composing

TODO

### 3. Codec, Decoder and Encoder

TODO