
[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-scala

This module contains implementation of `e-core` written in Scala.

## E

[`E`](src/main/scala/e/scala/E.scala) provides a concrete implementation of `AbstractE` as an immutable case class. Any modifications on an `E` instance return a new instance.

Here are some examples:

```scala
import e.scala._

/***********************/
/* Empty E definitions */
/***********************/

E.empty
// res0: E = E("", "", 0, None, Map())

E()
// res1: E = E("", "", 0, None, Map())

/**********************************************************************************/
/* Constructing an E, mix and match constuctor and builder methods as you see fit */
/**********************************************************************************/

val ae = new java.lang.ArithmeticException()
// ae: ArithmeticException = java.lang.ArithmeticException

E(name = "arithmetic-error", message = "Cannot divide number by 0!", code = 1, cause = Some(ae), data = Map("input" -> "5"))
// res2: E = E(
//   "arithmetic-error",
//   "Cannot divide number by 0!",
//   1,
//   Some(java.lang.ArithmeticException),
//   Map("input" -> "5")
// )

E.empty.name("arithmetic-error").message("Cannot divide number by 0!").code(1).cause(ae).data("input" -> "5")
// res3: E = E(
//   "arithmetic-error",
//   "Cannot divide number by 0!",
//   1,
//   Some(java.lang.ArithmeticException),
//   Map("input" -> "5")
// )

E("arithmetic-error", "Cannot divide number by 0!").cause(ae).data("input", "5")
// res4: E = E(
//   "arithmetic-error",
//   "Cannot divide number by 0!",
//   0,
//   Some(java.lang.ArithmeticException),
//   Map("input" -> "5")
// )

/****************************************/
/* Checking existence of fields of an E */
/****************************************/

val errorContainsCode = E("error").hasCode
// errorContainsCode: Boolean = false

/****************************/
/* Accessing fields of an E */
/****************************/

val errorContainsInput = E(data = Map("input" -> "test")).data.get("input").isDefined
// errorContainsInput: Boolean = true

/*************************************************************/
/* Converting E to an Exception, for throwing stuff (unsafe) */
/*************************************************************/

E(message = "test").toException
// res5: Exception = java.lang.Exception: test

/*******************************************************/
/* Converting E to a Maybe, for returning stuff (safe) */
/*******************************************************/

E("error").toMaybe[Int]
// res6: Maybe[Int] = Failure(E("error", "", 0, None, Map()))
```

## Maybe

[`Maybe`](src/main/scala/e/scala/Maybe.scala) provides a type safe way to denote a value that can contain an `E`. `Maybe[A]` wraps `Either[E, A]`. It can either be a [`Maybe.Failure`](src/main/scala/e/scala/Maybe.scala) containing an `E` or a [`Maybe.Success`](src/main/scala/e/scala/Maybe.scala) containing a value.

Here are some examples:

```scala
import e.scala._

// for conversions and syntax extensions
import e.scala.implicits._

/********************************/
/* Constructing a success Maybe */
/********************************/

val maybe1: Maybe[Int] = Maybe.Success(5)
// maybe1: Maybe[Int] = Success(5)

val maybe2 = Maybe.success("foo")
// maybe2: Maybe[String] = Success("foo")

val maybe3 = true.toMaybe
// maybe3: Maybe[Boolean] = Success(true)

/********************************/
/* Constructing a failure Maybe */
/********************************/

val maybe4: Maybe[Int] = Maybe.Failure(E("e-1"))
// maybe4: Maybe[Int] = Failure(E("e-1", "", 0, None, Map()))

val maybe5 = Maybe.failure[String](E("e-2"))
// maybe5: Maybe[String] = Failure(E("e-2", "", 0, None, Map()))

val maybe6 = E("e-3").toMaybe[Boolean]
// maybe6: Maybe[Boolean] = Failure(E("e-3", "", 0, None, Map()))

/*****************************/
/* Constructing a unit Maybe */
/*****************************/

Maybe.unit
// res7: Maybe[Unit] = Success(())

/*******************************/
/* Checking content of a Maybe */
/*******************************/

5.toMaybe.isSuccess
// res8: Boolean = true

E("error").toMaybe[Int].isSuccess
// res9: Boolean = false

5.toMaybe.eOpt
// res10: Option[E] = None

E("error").toMaybe[Int].eOpt
// res11: Option[E] = Some(E("error", "", 0, None, Map()))

5.toMaybe.valueOpt
// res12: Option[Int] = Some(5)

E("error").toMaybe[Int].valueOpt
// res13: Option[Int] = None

true.toMaybe match {
  case Maybe.Failure(e)     => "false"
  case Maybe.Success(value) => value.toString
}
// res14: String = "true"

E("error").toMaybe[Boolean] match {
  case Maybe.Failure(e)     => "failure"
  case Maybe.Success(value) => "success"
}
// res15: String = "failure"

/*******************/
/* Mapping a Maybe */
/*******************/

E("error").toMaybe[Int].map(i => i * 2)
// res16: Maybe[Int] = Failure(E("error", "", 0, None, Map()))

5.toMaybe.map(i => i * 2)
// res17: Maybe[Int] = Success(10)

/************************/
/* Flat mapping a Maybe */
/************************/

E("error").toMaybe[Int].flatMap(i => (i * 2).toMaybe)
// res18: Maybe[Int] = Failure(E("error", "", 0, None, Map()))

5.toMaybe.flatMap(i => E("error").toMaybe[Boolean])
// res19: Maybe[Boolean] = Failure(E("error", "", 0, None, Map()))

5.toMaybe.flatMap(i => (i * 2).toString.toMaybe)
// res20: Maybe[String] = Success("10")

/*******************/
/* Folding a Maybe */
/*******************/

E("error").toMaybe[Int].fold(e => "failure", value => "success")
// res21: String = "failure"

5.toMaybe.fold(e => "failure", value => "success")
// res22: String = "success"

/**********************************************************/
/* Getting value of a Maybe and providing a default value */
/**********************************************************/

E("error").toMaybe[Int].getOrElse(0)
// res23: Int = 0

"test".toMaybe.getOrElse("")
// res24: String = "test"

/************************************/
/* Providing an alternative a Maybe */
/************************************/

E("error1").toMaybe[Int] orElse E("error2").toMaybe[Int]
// res25: Maybe[Int] = Failure(E("error2", "", 0, None, Map()))

E("error1").toMaybe[Int] orElse  "default".toMaybe
// res26: Maybe[Any] = Success("default")

"test-1".toMaybe orElse E("error").toMaybe[String]
// res27: Maybe[String] = Success("test-1")

"test-1".toMaybe orElse "test-2".toMaybe
// res28: Maybe[String] = Success("test-1")

/*******************************************************/
/* Ignoring previous value and moving to another Maybe */
/*******************************************************/

E("error1").toMaybe[Int] andThen E("error2").toMaybe[Int]
// res29: Maybe[Int] = Failure(E("error1", "", 0, None, Map()))

E("error1").toMaybe[Int] andThen "default".toMaybe
// res30: Maybe[String] = Failure(E("error1", "", 0, None, Map()))

"test".toMaybe andThen E("error").toMaybe[String]
// res31: Maybe[String] = Failure(E("error", "", 0, None, Map()))

"test-1".toMaybe andThen "test-2".toMaybe
// res32: Maybe[String] = Success("test-2")

/*********************/
/* Filtering a Maybe */
/*********************/

E("error").toMaybe[Int].filter(_ < 4)
// res33: Maybe[Int] = Failure(E("error", "", 0, None, Map()))

E("error").toMaybe[Int].filter(_ < 4, i => E("error").data("value", i))
// res34: Maybe[Int] = Failure(E("error", "", 0, None, Map()))

5.toMaybe.filter(_ < 4)
// res35: Maybe[Int] = Failure(
//   E(
//     "predicate-failed",
//     "Value did not satisfy predicate!",
//     0,
//     None,
//     Map("value" -> "5")
//   )
// )

5.toMaybe.filter(_ < 4, i => E("error").data("value", i))
// res36: Maybe[Int] = Failure(E("error", "", 0, None, Map("value" -> "5")))

5.toMaybe.filter(_ > 4)
// res37: Maybe[Int] = Success(5)

5.toMaybe.filter(_ > 4, i => E("error").data("value", i))
// res38: Maybe[Int] = Success(5)

/******************************************/
/* Using a Maybe to perform a side effect */
/******************************************/

val sb1 = new StringBuilder
// sb1: StringBuilder = IndexedSeq()

val sb2 = new StringBuilder
// sb2: StringBuilder = IndexedSeq('t', 'e', 's', 't')

E("error").toMaybe[String].foreach(s => sb1.append(s))

"test".toMaybe.foreach(s => sb2.append(s))

sb1.toString()
// res41: String = ""

sb2.toString()
// res42: String = "test"

/*****************************/
/* Handling error of a Maybe */
/*****************************/

E("error-1").toMaybe[Int].handleError { case _ => 0 }
// res43: Maybe[Int] = Success(0)

E("error-1").toMaybe[Int].handleError { case e if e.hasName => 0 }
// res44: Maybe[Int] = Success(0)

E().toMaybe[Int].handleError { case e if e.hasName => 0 }
// res45: Maybe[Int] = Failure(E("", "", 0, None, Map()))

5.toMaybe.handleError { case _ => 0 }
// res46: Maybe[Int] = Success(5)

5.toMaybe.handleError { case e if e.hasName => 0 }
// res47: Maybe[Int] = Success(5)

/************************************************/
/* Handling error of a Maybe with another Maybe */
/************************************************/

E("error-1").toMaybe[Int].handleErrorWith { case _ => E().toMaybe[Int] }
// res48: Maybe[Int] = Failure(E("", "", 0, None, Map()))

E("error-1").toMaybe[Int].handleErrorWith { case _ => 5.toMaybe }
// res49: Maybe[Int] = Success(5)

E("error-1").toMaybe[Int].handleErrorWith { case e if e.hasName => 0.toMaybe }
// res50: Maybe[Int] = Success(0)

E("error-1").toMaybe[Int].handleErrorWith { case e if e.hasName => E().toMaybe[Int] }
// res51: Maybe[Int] = Failure(E("", "", 0, None, Map()))

E().toMaybe[Int].handleErrorWith { case e if e.hasName => 0.toMaybe }
// res52: Maybe[Int] = Failure(E("", "", 0, None, Map()))

E().toMaybe[Int].handleErrorWith { case e if e.hasName => E("error-1").toMaybe[Int] }
// res53: Maybe[Int] = Failure(E("", "", 0, None, Map()))

5.toMaybe.handleErrorWith { case _ => E().toMaybe[Int] }
// res54: Maybe[Int] = Success(5)

5.toMaybe.handleErrorWith { case _ => 0.toMaybe }
// res55: Maybe[Int] = Success(5)

5.toMaybe.handleErrorWith { case e if e.hasName => E().toMaybe[Int] }
// res56: Maybe[Int] = Success(5)

5.toMaybe.handleErrorWith { case e if e.hasName => 0.toMaybe }
// res57: Maybe[Int] = Success(5)

/************************************/
/* Constructing a Maybe from Option */
/************************************/

Maybe.fromOption(Option.empty[String], E("error"))
// res58: Maybe[String] = Failure(E("error", "", 0, None, Map()))

Option.empty[String].toMaybe(E("error"))
// res59: Maybe[String] = Failure(E("error", "", 0, None, Map()))

Maybe.fromOption(Some(3), E("error"))
// res60: Maybe[Int] = Success(3)

Some(3).toMaybe(E("error"))
// res61: Maybe[Int] = Success(3)

/************************************/
/* Constructing a Maybe from Either */
/************************************/

Maybe.fromEither[Int, String](Left(1), left => E(code = left))
// res62: Maybe[String] = Failure(E("", "", 1, None, Map()))

Left[Int, String](1).toMaybe(left => E(code = left))
// res63: Maybe[String] = Failure(E("", "", 1, None, Map()))

Maybe.fromEither[Int, String](Right("test"), _ => E("error"))
// res64: Maybe[String] = Success("test")

Right[Int, String]("test").toMaybe(_ => E("error"))
// res65: Maybe[String] = Success("test")

// When Left is E, conversion is done implicitly

val maybeFromEither1: Maybe[String] = Left[E, String](E("error"))
// maybeFromEither1: Maybe[String] = Failure(E("error", "", 0, None, Map()))

val maybeFromEither2: Maybe[Int] = Right[E, Int](5)
// maybeFromEither2: Maybe[Int] = Success(5)

/*********************************/
/* Constructing a Maybe from Try */
/*********************************/

Maybe.fromTry[Boolean](scala.util.Failure(new Exception("test")), t => E(cause = Some(t)))
// res66: Maybe[Boolean] = Failure(
//   E("", "", 0, Some(java.lang.Exception: test), Map())
// )

scala.util.Failure[Boolean](new Exception("test")).toMaybe(t => E(cause = Some(t)))
// res67: Maybe[Boolean] = Failure(
//   E("", "", 0, Some(java.lang.Exception: test), Map())
// )

Maybe.fromTry[Int](scala.util.Success(5), t => E(cause = Some(t)))
// res68: Maybe[Int] = Success(5)

scala.util.Success[Int](5).toMaybe(t => E(cause = Some(t)))
// res69: Maybe[Int] = Success(5)

/*******************************************/
/* Constructing a Maybe by catching lambda */
/*******************************************/

Maybe.catching(c => E().cause(c)) { throw new Exception() }
// res70: Maybe[Nothing] = Failure(
//   E("", "", 0, Some(java.lang.Exception), Map())
// )

Maybe.catching(c => E().cause(c)) { "test" }
// res71: Maybe[String] = Success("test")

/*************************************************/
/* Constructing a Maybe by catching Maybe lambda */
/*************************************************/

Maybe.catchingMaybe(c => E().cause(c)) { throw new Exception() }
// res72: Maybe[Nothing] = Failure(
//   E("", "", 0, Some(java.lang.Exception), Map())
// )

Maybe.catchingMaybe(c => E().cause(c)) { E().toMaybe[String] }
// res73: Maybe[String] = Failure(E("", "", 0, None, Map()))

Maybe.catchingMaybe(c => E().cause(c)) { "test".toMaybe }
// res74: Maybe[String] = Success("test")
```

`Maybe` can be used in for-comprehensions since it defines `map`, `flatMap`, `withFilter` and `foreach`.

```scala
import e.scala._
import e.scala.implicits._

def find(id: Int): Maybe[String] =
  id match {
    case 1 => "1".toMaybe
    case 2 => "2".toMaybe
    case _ => E("not-found").toMaybe[String]
  }  

def convert(s: String): Maybe[Int] =
  for {
    s      <- Maybe.catching(t => E("invalid").cause(t)) { s.toInt }
    result  = s * 2
  } yield {
    result
  }

for {
  s <- find(2)
  r <- convert(s) if r < 5
} {
  println(r)
}
// 4
```

## Encoder

[`Encoder[OUT]`](src/main/scala/e/scala/Codec.scala) provides encode functionality such that given `E` can be converted to another value of type `OUT`. There is [`JsonStringEncoder`](src/main/scala/e/scala/JsonStringEncoder.scala) as a default `Encoder[String]` implementation.

```scala
import e.scala._

// for conversions and syntax extensions
import e.scala.implicits._

/*******************************/
/* Default Json string encoder */
/*******************************/

val encoder: Encoder[String] = JsonStringEncoder
// encoder: Encoder[String] = e.scala.JsonStringEncoder$@43051483

encoder.encode(E())
// res76: String = "{}"

encoder.encode(E("test-name", "Test Message", 3, Some(new Exception("Test Cause")), Map("test" -> "data")))
// res77: String = "{\"name\":\"test-name\",\"message\":\"Test Message\",\"code\":3,\"cause\":\"Test Cause\",\"data\":{\"test\":\"data\"}}"

/******************************************************/
/* Custom CSV-like encoder for demonstration purposes */
/******************************************************/

val csv: Encoder[String] = { e: E =>
  s""""name","message","code"
     |"${e.name}","${e.message}","${e.code}"
   """.stripMargin
}
// csv: Encoder[String] = repl.Session$App$$anonfun$161@3a827b3e

csv.encode(E())
// res78: String = """"name","message","code"
// "","","0"
//    """

csv.encode(E("test-name", "Test Message", 3, Some(new Exception("Test Cause")), Map("test" -> "data")))
// res79: String = """"name","message","code"
// "test-name","Test Message","3"
//    """
```

## Decoder

[`Decoder[IN]`](src/main/scala/e/scala/Codec.scala) provides decode functionality such that given an input of type `IN`, an `E` can be constructed. Since decoding often includes parsing, it can possibly fail. `DecoderResult` exists for this purpose. It can either contain successfully decoded `E` or an `E` describing the error occurred during decoding.

```scala
import e.scala._

// for conversions and syntax extensions
import e.scala.implicits._

import e.AbstractDecoder.DecodingResult

/******************************************************/
/* Custom CSV-like decoder for demonstration purposes */
/******************************************************/

val csvDecoder: Decoder[String] = new Decoder[String] {
  override def decode(input: String): DecodingResult[E] = {
    input.linesIterator.slice(1, 2).nextOption() match {
      case None =>
        DecodingResult.fail(E("decoding-failure", "Input did not have 2 rows!"))

      case Some(line) =>
        line.split(",") match {
          case Array(rawName, rawMessage, rawCode) =>
            val name    = unescape(rawName)
            val message = unescape(rawMessage)

            scala.util.Try(unescape(rawCode).toInt).fold(
              c    => DecodingResult.fail(E("decoding-failure", "Invalid code!").cause(c).data("code" -> rawCode)),
              code => DecodingResult.succeed(E(name, message, code))
            )
            
          case _ =>
            DecodingResult.fail(E("decoding-failure", "Input did not have 3 columns!"))
        }
    }
  }

  private def unescape(s: String): String =
    if (s.startsWith("\"") && s.endsWith("\"")) s.drop(1).dropRight(1) else s
}
// csvDecoder: Decoder[String] = repl.Session$App$$anon$1@144e0035

val result1 = csvDecoder.decode("foo")
// result1: DecodingResult[E] = {"name":"decoding-failure","message":"Input did not have 2 rows!"}

result1.isSuccess
// res80: Boolean = false

result1.get
// res81: E = E(
//   "decoding-failure",
//   "Input did not have 2 rows!",
//   0,
//   None,
//   Map()
// )

val result2 = csvDecoder.decode(
  """"name","message","code"
    |"test-name","Test Message","1"
  """.stripMargin
)
// result2: DecodingResult[E] = {"name":"test-name","message":"Test Message","code":1}

result2.isSuccess
// res82: Boolean = true

result2.get
// res83: E = E("test-name", "Test Message", 1, None, Map())

val either1 = csvDecoder.decodeEither("foo")
// either1: Either[E, E] = Left(
//   E("decoding-failure", "Input did not have 2 rows!", 0, None, Map())
// )

either1.isLeft
// res84: Boolean = true

val either2 = csvDecoder.decodeEither(
  """"name","message","code"
    |"test-name","Test Message","1"
  """.stripMargin
)
// either2: Either[E, E] = Right(
//   E("test-name", "Test Message", 1, None, Map())
// )

either2.isRight
// res85: Boolean = true
```

## Codec

[`Codec[A]`](src/main/scala/e/scala/Codec.scala) is simply a combination of both `Encoder[A]` and `Decoder[A]` for the same type `A`.
