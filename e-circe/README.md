[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-circe [![](https://img.shields.io/badge/docs-3.0.0-SNAPSHOT-brightgreen.svg?style=for-the-badge&logo=scala&color=dc322f&labelColor=333333)](https://javadoc.io/doc/dev.akif/e-circe_3)

This is a Json codec implementation for `E` and `EOr` types based on [circe](https://circe.github.io/circe). It provides circe's `Decoder`s and `Encoder`s as well as e's own `Codec` (see [e-scala](/e-scala/README.md#3-codec-decoder-and-encoder) docs).

## Installation

If you use SBT, add following to your `build.sbt`:

```scala
libraryDependencies += "dev.akif" %% "e-circe" % "3.0.0-SNAPSHOT"
```

If you use Maven, add following to your `pom.xml`:

```xml

<dependencies>
    <dependency>
        <groupId>dev.akif</groupId>
        <artifactId>e-circe_3</artifactId>
        <version>3.0.0-SNAPSHOT</version>
    </dependency>
</dependencies>
```

If you use Gradle, add following to your project's `build.gradle`:

```javascript
dependencies
{
    implementation('dev.akif:e-circe_3:3.0.0-SNAPSHOT')
}
```

## Contents

Below are some details and examples of e-circe's content. For more, please check corresponding automated tests and e-circe's documentation.

To get started, add following import which will cover all your needs:

```scala
import e.circe.{*, given}
```

### 1. Decoding

e-circe provides implicit definitions so that regular circe decoding can be done. However, it also provides e's own Codec. Using this is convenient as it reports decoding failures as E errors.

#### 1.1. Decoding a Value

```scala
import e.circe.{*, given}
import io.circe.{Decoder => CirceDecoder, Encoder => CirceEncoder, Json}
import io.circe.syntax.*

decode[String](123.asJson)
// res1: EOr[String] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"message":"Got value '123' with wrong type, expecting string"}]}

decode[String]("test".asJson)
// res2: EOr[String] = test

case class Foo(bar: Boolean)

given fooDecoder: CirceDecoder[Foo] = CirceDecoder.forProduct1("bar")(Foo.apply)

given fooEncoder: CirceEncoder[Foo] = CirceEncoder.forProduct1("bar")(_.bar)

decode[Foo](Json.obj())
// res3: EOr[Foo] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":".bar","message":"Missing required field"}]}

decode[Foo](Foo(false).asJson)
// res4: EOr[Foo] = Foo(false)
```

#### 1.2. Decoding an E

Decoding a Json as E yields `EOr[E]` whose error is the decoding failure. If the decoding succeeds, the provided value is the decoded E.

```scala
import e.circe.{*, given}
import e.scala.E
import io.circe.Json
import io.circe.syntax.*

// Decodes as `E.empty`
decode[E](Json.obj())
// res6: EOr[E] = {}

// Decoding failure, also an E
decode[E](Json.arr())
// res7: EOr[E] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"message":"Expected: JsonObject"}]}

val decoder = makeDecoder[E]
// decoder: Decoder[Json, E] = e.scala.codec.CodecFor$$Lambda/0x0000000303c00e40@7b898871

decoder.decode(Json.obj("code" := 1, "name" := "test"))
// res8: EOr[E] = {"code":1,"name":"test"}
```

### 2. Encoding

e-circe provides implicit definitions so that regular circe encoding can be done. It also provides e's own Codec and encoding can be done with it too.

#### 2.1. Encoding an E

```scala
import e.circe.{*, given}
import e.scala.E

encode(E.empty)
// res10: Json = {
//   
// }

encode(E.name("test").message("Test").cause(E.code(1)))
// res11: Json = {
//   "name" : "test",
//   "message" : "Test",
//   "causes" : [
//     {
//       "code" : 1
//     }
//   ]
// }

val encoder = makeEncoder[E]
// encoder: Encoder[E, Json] = e.scala.codec.CodecFor$$Lambda/0x0000000303c07420@b36987b

encoder.encode(E.code(2))
// res12: Json = {
//   "code" : 2
// }
```

#### 2.2. Encoding an EOr

```scala
import e.circe.{*, given}
import e.scala.*

encode[EOr[String]](E.name("test").toEOr[String])
// res14: Json = {
//   "name" : "test"
// }

encode[EOr[Int]](123.toEOr)
// res15: Json = 123

val encoder = makeEncoder[EOr[String]]
// encoder: Encoder[EOr[String], Json] = e.scala.codec.CodecFor$$Lambda/0x0000000303c07420@69ea67a

encoder.encode(E.name("test").toEOr[String])
// res16: Json = {
//   "name" : "test"
// }

encoder.encode("123".toEOr)
// res17: Json = "123"
```

### 3. Codec

Since e's Codec is a combination of decoding and encoding, you can use `makeCodec` instead of separately using `makeDecoder` and `makeEncoder` if you have both capabilities for a type.

```scala
import e.circe.{*, given}
import e.scala.*
import io.circe.{Decoder => CirceDecoder, Encoder => CirceEncoder, Json}
import io.circe.syntax.*

case class User(name: String, age: Int)

object User:
    given userDecoder: CirceDecoder[User] = CirceDecoder.forProduct2("n", "a")(User.apply)

    given userEncoder: CirceEncoder[User] = CirceEncoder.forProduct2("n", "a")(u => (u.name, u.age))

val codec = makeCodec[User]
// codec: Codec[User, Json] = e.scala.codec.CodecFor$$anon$1@721ad5cf

codec.decode(Json.obj("foo" := "bar"))
// res19: EOr[User] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":".n","message":"Missing required field"},{"name":".a","message":"Missing required field"}]}

codec.decode(Json.obj("n" := "Akif", "a" := 29))
// res20: EOr[User] = User(Akif,29)

codec.encode(User("Akif", 29))
// res21: Json = {
//   "n" : "Akif",
//   "a" : 29
// }
```
