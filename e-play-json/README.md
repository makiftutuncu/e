[//]: # "This file is generated by [mdoc](https://scalameta.org/mdoc). Do not edit it directly as it will be overwritten. Instead edit corresponding file in docs folder."

# e-play-json [![](https://img.shields.io/badge/docs-2.0.2-brightgreen.svg?style=for-the-badge&logo=scala&color=dc322f&labelColor=333333)](https://javadoc.io/doc/dev.akif/e-play-json_2.13)

This is a Json codec implementation for `E` and `EOr` types based on [play-json]((https://github.com/playframework/play-json)). It provides play-json's `Reads` and `Writes` as well as e's own `Codec` (see [e-scala](/e-scala/README.md#3-codec-decoder-and-encoder) docs).

## Installation

If you use SBT, add following to your `build.sbt`:

```scala
libraryDependencies += "dev.akif" %% "e-play-json" % "2.0.2"
```
If you use Maven, add following to your `pom.xml` (replace 2.13 if you need a different Scala version):

```xml
<dependencies>
  <dependency>
    <groupId>dev.akif</groupId>
    <artifactId>e-play-json_2.13</artifactId>
    <version>2.0.2</version>
  </dependency>
</dependencies>
```
If you use Gradle, add following to your project's `build.gradle` (replace 2.13 if you need a different Scala version):

```javascript
dependencies {
  implementation('dev.akif:e-play-json_2.13:2.0.2')
}
```

## Contents

Below are some details and examples of e-play-json's content. For more, please check corresponding automated tests and e-play-json's documentation.

To get started, add following import which will cover all your needs:

```scala
import e.playjson._
```

### 1. Decoding

e-play-json provides implicit definitions so that regular play-json reading can be done. However, it also provides e's own Codec. Using this is convenient as it reports decoding failures as E errors.

#### 1.1. Decoding a Value

```scala
import e.playjson._
import play.api.libs.json._

decode[String](Json.toJson(123))
// res1: e.scala.EOr[String] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":"obj","message":"error.expected.jsstring"}]}

decode[String](Json.toJson("test"))
// res2: e.scala.EOr[String] = test

case class Foo(bar: Boolean)

implicit val fooReads: Reads[Foo] = Json.reads[Foo]
// fooReads: Reads[Foo] = play.api.libs.json.Reads$$anon$6@dfb8284

implicit val fooWrites: Writes[Foo] = Json.writes[Foo]
// fooWrites: Writes[Foo] = play.api.libs.json.OWrites$$anon$4@2f50b87a

decode[Foo](Json.obj())
// res3: e.scala.EOr[Foo] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":"obj.bar","message":"error.path.missing"}]}

decode[Foo](Json.toJson(Foo(false)))
// res4: e.scala.EOr[Foo] = Foo(false)
```

#### 1.2. Decoding an E

Reading a Json as E yields `EOr[E]` whose error is the decoding failure. If the decoding succeeds, the provided value is the decoded E.

```scala
import e.playjson._
import e.scala.E
import play.api.libs.json._

// Decodes as `E.empty`
decode[E](Json.obj())
// res6: e.scala.EOr[E] = {}

// Decoding failure, also an E
decode[E](Json.arr())
// res7: e.scala.EOr[E] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":"obj","message":"error.expected.jsobject"}]}

val decoder = makeDecoder[E]
// decoder: e.scala.codec.Decoder[JsValue, E] = e.scala.codec.CodecFor$$Lambda$13621/0x0000000803544890@2b7df3a8

decoder.decode(Json.obj("code" -> 1, "name" -> "test"))
// res8: e.scala.EOr[E] = {"code":1,"name":"test"}
```

### 2. Encoding

e-play-json provides implicit definitions so that regular play-json writing can be done. It also provides e's own Codec and encoding can be done with it too.

#### 2.1. Encoding an E

```scala
import e.playjson._
import e.scala.E

encode(E.empty)
// res10: play.api.libs.json.JsValue = {}

encode(E.name("test").message("Test").cause(E.code(1)))
// res11: play.api.libs.json.JsValue = {"name":"test","message":"Test","causes":[{"code":1}]}

val encoder = makeEncoder[E]
// encoder: e.scala.codec.Encoder[E, play.api.libs.json.JsValue] = e.scala.codec.CodecFor$$Lambda$13626/0x0000000803547dd0@10cb3673

encoder.encode(E.code(2))
// res12: play.api.libs.json.JsValue = {"code":2}
```

#### 2.2. Encoding an EOr

```scala
import e.playjson._
import e.scala._

encode[EOr[String]](E.name("test").toEOr[String])
// res14: play.api.libs.json.JsValue = {"name":"test"}

encode[EOr[Int]](123.toEOr)
// res15: play.api.libs.json.JsValue = 123

val encoder = makeEncoder[EOr[String]]
// encoder: codec.Encoder[EOr[String], play.api.libs.json.JsValue] = e.scala.codec.CodecFor$$Lambda$13626/0x0000000803547dd0@4c8c98d8

encoder.encode(E.name("test").toEOr[String])
// res16: play.api.libs.json.JsValue = {"name":"test"}

encoder.encode("123".toEOr)
// res17: play.api.libs.json.JsValue = "123"
```

### 3. Codec

Since e's Codec is a combination of decoding and encoding, you can use `makeCodec` instead of separately using `makeDecoder` and `makeEncoder` if you have both capabilities for a type.

```scala
import e.playjson._
import e.scala._
import play.api.libs.json._

case class User(name: String, age: Int)

object User {
  implicit val userFormat: Format[User] = Json.format[User]
}

val codec = makeCodec[User]
// codec: e.scala.codec.Codec[User, JsValue] = e.scala.codec.CodecFor$$anon$1@521e7c5

codec.decode(Json.obj("foo" -> "bar"))
// res19: EOr[User] = {"name":"decoding-error","message":"Failed to decode!","causes":[{"name":"obj.age","message":"error.path.missing"},{"name":"obj.name","message":"error.path.missing"}]}

codec.decode(Json.obj("name" -> "Akif", "age" -> 29))
// res20: EOr[User] = User(Akif,29)

codec.encode(User("Akif", 29))
// res21: JsValue = {"name":"Akif","age":29}
```
